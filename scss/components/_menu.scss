// Foundation for Sites by ZURB
// foundation.zurb.com
// Licensed under MIT Open Source

////////////////////////////////////////
/// @group menu
////////////////////////////////////////

//--------------------------------------
// Colors
//
/// Text color of an active menu item.
/// @type Color
$menu-item-color-active: $global-menu-item-color-active !default;

/// Background color of an active menu item.
/// @type Color
$menu-item-background-active: $global-menu-item-background-active !default;

/// Background color for an hovered menu item.
/// @type Color
$menu-item-background-hover: $global-menu-item-background-hover !default;

/// Color for bordered menu
/// @type Color
$menu-border: $global-menu-border !default;


$menu-text-color: $global-menu-text-color !default;


//--------------------------------------
// Status
//

$menu-first-line-zero-padiing-left-status: true !default;


//--------------------------------------
// Sizes
//
/// Margin of a menu.
/// @type Number
$menu-margin: 0 0 1rem !default;

/// Left-hand margin of a nested menu.
/// @type Number
$menu-margin-nested: 1rem !default;

/// Padding for items in a menu.
/// @type Number
$menu-item-padding: rem-calc(6) rem-calc(16) !default;

/// Spacing between an icon and text in a menu item.
/// @type Number
$menu-icon-spacing: .25rem !default;

/// Maximum number of `expand-n` classes to include in the CSS.
/// @type Number
$menu-expand-max: 6 !default;


$menu-font-size: rem-calc(16) !default;
$menu-font-weight: bold !default;
$menu-text-font-weight: bold !default;
$menu-border-width: 1px !default;
$menu-border-style: solid !default;


////////////////////////////////////////
////////////////////////////////////////
////////////////////////////////////////
/// @group menu
////////////////////////////////////////

/// Creates the base styles for a Menu.
@mixin menu-base {
  margin: $menu-margin;
  list-style-type: none;
  @if $menu-font-weight != normal {
    font-weight: $menu-font-weight;
  }

  @if $global-flexbox {
    align-items: center;
    display: flex;
    flex-wrap: nowrap;
    width: 100%;
  }

  &:focus {
    outline: 0;
  }

  // List items are table cell to allow for vertical alignment
  > li {
    @include disable-mouse-outline;

    @if $global-flexbox {
      flex: 0 0 auto;
    } @else {
      display: table-cell;
      vertical-align: middle;
    }
  }

  // Reset line height to make the height of the overall item easier to calculate
  > li > a {
    display: block;
    line-height: 1;

    @if type-of($menu-item-padding) == 'map' {
      @each $breakpoint, $value in $menu-item-padding {
        @include breakpoint($breakpoint) {
          padding: $value;
        }
      }
    } @else {
      padding: $menu-item-padding;
    }

    &:focus {
      outline: 0;
    }
  }

  // Reset styles of inner elements
  input,
  select,
  a,
  button {
    margin-bottom: 0;
  }
}

/// Expands the items of a Menu, so each item is the same width.
@mixin menu-expand {
  @if $global-flexbox {
    > li {
      flex: 1 1 0px; // scss-lint:disable ZeroUnit
    }
  } @else {
    display: table;
    table-layout: fixed;
    width: 100%;
  }

  > li:first-child:last-child {
    width: 100%;
  }
}

/// Sets the direction of a Menu.
/// @param {Keyword} $dir [horizontal] - Direction of the Menu. Can be `horizontal` or `vertical`.
@mixin menu-direction(
  $dir: horizontal ) {

  @if $dir == horizontal {
    @if $global-flexbox {
      flex-wrap: nowrap;

      > li {
        flex: 0 0 auto;
      }
    } @else {
      > li {
        display: table-cell;
      }
    }
  } @else if $dir == vertical {
    @if $global-flexbox {
      flex-wrap: wrap;

      > li {
        flex: 0 0 100%;
        max-width: 100%;
      }

      > li  > a {
        align-items: flex-start;
        justify-content: flex-start;
      }
    } @else {
      > li {
        display: block;
      }
    }
  } @else {
    @warn 'The direction used for menu-direction() must be horizontal or vertical.';
  }
}

/// Creates a simple Menu, which has no padding or hover state.
/// @param {Keyword} $dir [$global-left] - Direction of the menu. Set to `null` to do not generate styles for direction.
@mixin menu-simple(
  $dir: $global-left ) {

  li {
    display: inline-block;
    line-height: 1;
    vertical-align: top;

    @if $dir != null {
      @include menu-simple-direction($dir);
    }
  }

  a {
    padding: 0;
  }
}

/// Direction modifier for a simple Menu
/// @param {Keyword} $dir [$global-left] - Direction of the menu
@mixin menu-simple-direction(
  $dir: $global-left ) {

  $no-margin-dir: $dir;
  $margin-dir: direction-opposite($dir);

  margin-#{$no-margin-dir}: 0;
  @if type-of($menu-item-padding) == 'map' {
    @each $breakpoint, $value in $menu-item-padding {
      @include breakpoint($breakpoint) {
        margin-#{$margin-dir}: get-side($value, $margin-dir);
      }
    }
  } @else {
    margin-#{$margin-dir}: get-side($menu-item-padding, $margin-dir);
  }
}

/// Adds styles for a nested Menu, by adding `margin-left` to the menu.
/// @param {Keyword|Number} $padding [auto] - Length of the margin.
@mixin menu-nested($margin: $menu-margin-nested) {
  @if $menu-first-line-zero-padiing-left-status {
    li > .nested {
      margin-#{$global-left}: $margin;
    }
  } @else {
    margin-#{$global-left}: $margin;
  }
}

/// Adds support for icons to Menu items.
/// @param {Keyword} $position [side] - Positioning for icons. Can be `side` (left, or right on RTL) or `top`.
/// @param {Boolean} $base [true] - Set to `false` to prevent the shared CSS between side- and top-aligned icons from being printed. Set this to `false` if you're calling the mixin multiple times on the same element.
@mixin menu-icons(
  $position: side,
  $base: true ) {

  @if $base {
    @if $global-flexbox {
      > li > a {
        display: flex;
      }
    } @else {
      > li > a {
        img,
        i,
        svg {
          vertical-align: middle;

          + span {
            vertical-align: middle;
          }
        }
      }
    }
  }

  @if $position == side {
    > li > a {
      @if $global-flexbox {
        flex-flow: row nowrap;
      }

      img,
      i,
      svg {
        margin-#{$global-right}: $menu-icon-spacing;

        @if not $global-flexbox {
          display: inline-block;
        }
      }
    }
  } @else if $position == top {
    > li > a {
      @if $global-flexbox {
        flex-flow: column nowrap;
      } @else {
        text-align: center;
      }

      img,
      i,
      svg {
        @if not $global-flexbox {
          display: block;
          margin: 0 auto $menu-icon-spacing;
        } @else {
          align-self: stretch;
          margin-bottom: $menu-icon-spacing;
          text-align: center;
        }
      }
    }
  }
}

@mixin menu-text {
  //line-height: 1;
  @if $menu-text-color != inherit {
    color: $menu-text-color;
  }
  @if $menu-text-font-weight != normal {
    font-weight: $menu-text-font-weight;
  }
  @if type-of($menu-item-padding) == 'map' {
    @each $breakpoint, $value in $menu-item-padding {
      @include breakpoint($breakpoint) {
        padding: $value;
      }
    }
  } @else {
    padding: $menu-item-padding;
  }
}

@mixin foundation-menu {
  .menu {
    @include menu-base;
    @include menu-icons;

    // Default orientation: horizontal
    &, &.horizontal {
      @include menu-direction(horizontal);
    }

    // Even-width modifier for horizontal orientation
    &.expanded {
      @include menu-expand;
    }

    // Vertical orientation modifier
    &.vertical {
      @include menu-direction(vertical);
    }

    @include -zf-each-breakpoint($small: false) {
      &.#{$-zf-size}-horizontal {
        @include menu-direction(horizontal);
      }

      &.#{$-zf-size}-expanded {
        @include menu-expand;
      }

      &.#{$-zf-size}-vertical {
        @include menu-direction(vertical);
      }
    }

    // Simple
    &.simple {
      @include menu-simple;

      &.align-#{$global-right} {
        @include menu-simple-direction($global-right);
      }
    }

    // Align right
    &.align-#{$global-right} {
      @if $global-flexbox {
        justify-content: flex-end;
      } @else {
        @include clearfix;

        > li {
          float: $global-right;
        }
      }
    }

    // // Even-width
    // &.expanded {
    //   @include menu-expand;
    //
    //   > li:first-child:last-child {
    //     width: 100%;
    //   }
    // }

    // Vertical icons
    &.icon-top {
      @include menu-icons(top, $base: false);
      // Make vertical menu with icons on top work
      &.vertical {
        a > span {
          margin: auto;
        }
      }
    }

    // Nesting
    &.nested {
      @include menu-nested;
    }

    // Active state
    .active > a {
      background: $menu-item-background-active;
      color: $menu-item-color-active;
    }

    @if $menu-first-line-zero-padiing-left-status {
      &:not(.nested) > li:first-child:not(.is-submenu-item) > a {
        padding-#{$global-left}: 0;
      }

      &.vertical:not(.nested):not(.small-horizontal):not(.medium-horizontal):not(.large-horizontal):not(.xlarge-horizontal):not(.xxlarge-horizontal) > li:not(.is-submenu-item) > a {
        padding-#{$global-left}: 0;
      }

      &.vertical:not(.nested) {
        &.medium-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(small down) {
            padding-#{$global-left}: 0;
          }
        }

        &.large-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(medium down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(large down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xxlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(xlarge down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xxxlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(xxlarge down) {
            padding-#{$global-left}: 0;
          }
        }
      }

      &:not(.nested) > li:last-child:not(.is-submenu-item) > a {
        padding-#{$global-right}: 0;
      }
    }

    // Menu with border
    &.menu-bordered {
      li {
        border: $menu-border-width $menu-border-style $menu-border;
        &:not(:first-child) {
          border-top: 0;
        }
      }
    }

    // Menu with background hover
    &.menu-hover {
      li:hover {
        background-color: $menu-item-background-hover;
      }
    }
  }

  .menu-text {
    @include menu-text;
  }

  // Align center
  .menu-centered {
    text-align: center;

    > .menu {
      @if $global-flexbox {
        @include flex-align($x: center, $y: top);
      } @else {
        display: inline-block;
        vertical-align: top;
      }
    }
  }

  // Prevent FOUC when using the Responsive Menu plugin
  .no-js [data-responsive-menu] ul {
    display: none;
  }

  @if not $menu-first-line-zero-padiing-left-status {
    .menu-first-line-zero-padiing.menu {
      &:not(.nested) > li:first-child:not(.is-submenu-item) > a {
        padding-#{$global-left}: 0;
      }

      &.vertical:not(.nested):not(.small-horizontal):not(.medium-horizontal):not(.large-horizontal):not(.xlarge-horizontal):not(.xxlarge-horizontal) > li:not(.is-submenu-item) > a {
        padding-#{$global-left}: 0;
      }

      &.vertical:not(.nested) {
        &.medium-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(small down) {
            padding-#{$global-left}: 0;
          }
        }

        &.large-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(medium down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(large down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xxlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(xlarge down) {
            padding-#{$global-left}: 0;
          }
        }

        &.xxxlarge-horizontal > li:not(.is-submenu-item) > a  {
          @include breakpoint(xxlarge down) {
            padding-#{$global-left}: 0;
          }
        }
      }

      &:not(.nested) > li:last-child:not(.is-submenu-item) > a {
        padding-#{$global-right}: 0;
      }
    }
  }
}
